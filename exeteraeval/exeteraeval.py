import os
import argparse
import time

import numpy as np

import h5py
import uuid

from exetera.core.session import Session

def generate_command(vsize, vcount, rootdir):

    if not os.path.exists(rootdir):
        os.mkdir(rootdir)
    elif os.path.isfile(rootdir):
        print("path {} exists and is a file; must be a directory".format(rootdir))
        exit(-1)

    r = np.random.RandomState(12345678)
    for i in range(vcount):
        np.save(os.path.join(rootdir, "right_data_{}".format(i)), r.randint(100, size=vsize, dtype=np.int32))

    np.save(os.path.join(rootdir, "ids"), np.arange(vsize, dtype=np.int64))

    mapping = [0, 1, 1, 2]
    len_mapping = len(mapping)
    left_ids = np.zeros(vsize, dtype=np.int64)

    for i in range(vsize):
        base = i // len_mapping
        in_map = i % len_mapping
        left_ids[i] = mapping[in_map] + base * len_mapping

    np.save(os.path.join(rootdir, "fk_ids"), left_ids)


def import_command(input, vcount, output):
    s = Session()
    with h5py.File(os.path.join(input, output), 'w') as hf:
        for name in ('fk_ids', 'ids'):
            print('importing "{}"'.format(name))
            n = np.load(os.path.join(input, '{}.npy').format(name))
            df = s.create_numeric(hf, name, 'int64')
            df.data.write(n)

        for v in range(vcount):
            print('importing "right_data_{}"'.format(v))
            n = np.load(os.path.join(input, 'right_data_{}.npy').format(v))
            df = s.create_numeric(hf, 'right_data_{}'.format(v), 'int32')
            df.data.write(n)


def exetera_test_left_merge_command(input, vcount):
    s = Session()
    with h5py.File(input, 'r') as hf:
        with h5py.File('{}.hdf5'.format(uuid.uuid4()), 'w') as dest:

            print(hf.keys())

            a_ids_f = s.get(hf['fk_ids'])
            b_ids_f = s.get(hf['ids'])

            all_b_val_fields = list()
            for v in range(vcount):
                b_vals_f = s.create_numeric(dest, 'left_data_{}'.format(v), 'int32')
                all_b_val_fields.append(b_vals_f)

            a_to_b = s.create_numeric(dest, 'a_to_b', 'int64')

            all_a_val_fields = list()
            for v in range(vcount):
                a_vals_f = s.get(hf['right_data_{}'.format(v)])
                all_a_val_fields.append(a_vals_f)

            print("running test")
            t0 = time.time()
            s.ordered_merge_left(a_ids_f, b_ids_f, left_to_right_map=a_to_b, right_unique=True,
                                 left_field_sources=tuple(all_a_val_fields),
                                 left_field_sinks=tuple(all_b_val_fields))
            elapsed = time.time() - t0
            print("total:", elapsed)
            results = s.merge_left(a_ids_f, b_ids_f, right_fields=tuple(all_a_val_fields))
            if not np.array_equal(all_b_val_fields[0].data[:], results[0]):
                print("warning: mismatched results")


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    subparsers = parser.add_subparsers(dest='command')
    subparsers.required = True

    generate_subcmd = subparsers.add_parser('generate_merge_dataset')
    generate_subcmd.add_argument('-s', '--size', required=True, type=int,
                                 help="the size of each field in number of elements")
    generate_subcmd.add_argument('-c', '--count', required=True, type=int,
                                 help="the number of fields to be generated (excluding the keys)")
    generate_subcmd.add_argument('-o', '--output', required=True,
                                 help="the directory to which the data should be written. This is"
                                    "created if it does not yet exist")

    import_subcmd = subparsers.add_parser('import_merge_dataset')
    import_subcmd.add_argument('-i', '--input', required=True,
                               help="the input folder containing the data generated by the generate command")
    import_subcmd.add_argument('-c', '--count', required=True, type=int,
                               help="the number of fields to be imported (must be equal to or lower than the number"
                                     "of fields generated by the generate command)")
    import_subcmd.add_argument('-o', '--output', required=True,
                               help="the name of the exetera dataset to write to (will overwrite an existing file)")

    ext_left_merge_subcmd = subparsers.add_parser('exetera_left_merge')
    ext_left_merge_subcmd.add_argument('-i', '--input', required=True,
                                       help="the input dataset")
    ext_left_merge_subcmd.add_argument('-c', '--count', required=True, type=int,
                                       help="the number of fields to be merged (must be equal to or lower than the"
                                            "number of fields imported by the import command)")

    args = parser.parse_args()

    if args.command == 'generate_merge_dataset':
        generate_command(args.size, args.count, args.output)
    elif args.command == 'import_merge_dataset':
        import_command(args.input, args.count, args.output)
    elif args.command == 'exetera_left_merge':
        exetera_test_left_merge_command(args.input, args.count)
    # else:
    #     print("command 'args.command' is not recognised")
